

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>4.3. 预处理数据(Preprocessing data) &#8212; scikit-learn 0.20.2 documentation</title>
<!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="../static/css/bootstrap.min.css" media="screen" />
<link rel="stylesheet" href="../static/css/bootstrap-responsive.css" />

    <link rel="stylesheet" href="../static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/js/copybutton.js"></script>
    <script type="text/javascript" src="../static/js/extra.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4.4. 缺失值处理(Imputation of missing values)" href="impute.html" />
    <link rel="prev" title="4.2. 特征提取(Feature extraction)" href="feature_extraction.html" />


<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="../static/js/bootstrap.min.js" type="text/javascript"></script>
<script>
  VERSION_SUBDIR = (function (groups) {
    return groups ? groups[1] : null;
  })(location.href.match(/^https?:\/\/scikit-learn.org\/([^\/]+)/));
</script>
<link rel="canonical" href="http://scikit-learn.org/stable/modules/preprocessing.html" />

<script type="text/javascript">
  $("div.buttonNext, div.buttonPrevious").hover(
    function () {
      $(this).css('background-color', '#FF9C34');
    },
    function () {
      $(this).css('background-color', '#A7D6E2');
    }
  );
  function showMenu() {
    var topNav = document.getElementById("scikit-navbar");
    if (topNav.className === "navbar") {
      topNav.className += " responsive";
    } else {
      topNav.className = "navbar";
    }
  };
</script>

<!-- 百度站长统计代码 -->
<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e7836e37a4cb7584127a787e9b44e3f1";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  </head><body>

<div class="header-wrapper">
  <div class="header">
    <p class="logo"><a href="../index.html">
        <img src="../static/scikit-learn-logo-small.png" alt="Logo" />
      </a>
    </p><div class="navbar" id="scikit-navbar">
      <ul>
        <li><a href="../index.html">首页</a></li>
        <li><a href="../install.html">安装</a></li>
        <li class="btn-li">
          <div class="btn-group">
            <a href="../documentation.html">文档</a>
            <a class="btn dropdown-toggle" data-toggle="dropdown">
              <span class="caret"></span>
            </a>
            <ul class="dropdown-menu">
              <li class="link-title">Scikit-learn
                <script>document.write(DOCUMENTATION_OPTIONS.VERSION + (VERSION_SUBDIR ? " (" + VERSION_SUBDIR + ")" : ""));</script>
              </li>
              <li><a href="../tutorial/index.html">教程</a></li>
              <li><a href="../user_guide.html">用户指南</a></li>
              <li><a href="classes.html">API</a></li>
              <li><a href="../glossary.html">词汇表</a></li>
              <li><a href="../faq.html">FAQ</a></li>
              <li><a href="../developers/contributing.html">贡献</a></li>
              <li><a href="../roadmap.html">路线图</a></li>
              <li class="divider"></li>
              <script>if (VERSION_SUBDIR != "stable") document.write('<li><a href="https://www.studyai.cn">稳定版</a></li>')</script>
              <script>if (VERSION_SUBDIR != "dev") document.write('<li><a href="http://scikit-learn.org/dev/documentation.html" target="_blank">开发版</a></li>')</script>
              <li><a href="http://scikit-learn.org/dev/versions.html">所有可用版本</a></li>
              <li><a href="../downloads/scikit-learn-docs.pdf">PDF 文档</a></li>
            </ul>
          </div>
        </li>
        <li><a href="../auto_examples/index.html">案例</a></li>
      </ul>
      <a href="javascript:void(0);" onclick="showMenu()">
        <div class="nav-icon">
          <div class="hamburger-line"></div>
          <div class="hamburger-line"></div>
          <div class="hamburger-line"></div>
        </div>
      </a>
      <div class="search_form">
        <div class="gcse-search" id="cse" style="width: 100%;"></div>
      </div>
    </div> <!-- end navbar --></div>
</div>


<!-- GitHub "fork me" ribbon -->
<a href="https://github.com/scikit-learn/scikit-learn">
  <img class="fork-me" style="position: absolute; top: 0; right: 0; border: 0;" src="../static/img/forkme.png"
    alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
  <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
      <div class="rel">
        
          <div class="rellink">
            <a href="feature_extraction.html" accesskey="P">Previous
              <br />
              <span class="smallrellink">
                4.2. 特征提取(Fea...
              </span>
              <span class="hiddenrellink">
                4.2. 特征提取(Feature extraction)
              </span>
            </a>
          </div>
          <div class="spacer">
            &nbsp;
          </div>
          <div class="rellink">
            <a href="impute.html" accesskey="N">Next
              <br />
              <span class="smallrellink">
                4.4. 缺失值处理(Im...
              </span>
              <span class="hiddenrellink">
                4.4. 缺失值处理(Imputation of missing values)
              </span>
            </a>
          </div>

          <!-- Ad a link to the 'up' page -->
          <div class="spacer">
            &nbsp;
          </div>
          <div class="rellink">
            <a href="../data_transforms.html">
              Up
              <br />
              <span class="smallrellink">
                4. 数据集变换
              </span>
                <span class="hiddenrellink">
                  4. 数据集变换
                </span>
                
            </a>
          </div>
        </div>
        
        <p class="doc-version"><b>scikit-learn v0.20.2</b><br />
          <a href="http://scikit-learn.org/dev/versions.html">其他版本</a></p>
        <!-- <p class="citing">Please <b><a href="../about.html#citing-scikit-learn" style="font-size: 110%;">cite
              us </a></b>if you use the software.</p> -->
        <p class="citing">该中文文档由人工智能社区的<a href="http://www.studyai.com/antares" target="_blank">Antares</a>翻译!
        </p>
        <ul>
<li><a class="reference internal" href="#">4.3. 预处理数据(Preprocessing data)</a><ul>
<li><a class="reference internal" href="#or">4.3.1. 标准化,or 均值去除和方差缩放</a><ul>
<li><a class="reference internal" href="#id2">4.3.1.1. 缩放特征到指定范围</a></li>
<li><a class="reference internal" href="#id3">4.3.1.2. 缩放稀疏数据</a></li>
<li><a class="reference internal" href="#id4">4.3.1.3. 缩放带有异常值的数据</a></li>
<li><a class="reference internal" href="#kernel-centering">4.3.1.4. 中心化 核矩阵</a></li>
</ul>
</li>
<li><a class="reference internal" href="#preprocessing-transformer">4.3.2. 非线性变换</a><ul>
<li><a class="reference internal" href="#id7">4.3.2.1. 映射到均匀分布</a></li>
<li><a class="reference internal" href="#id8">4.3.2.2. 映射到高斯分布</a></li>
</ul>
</li>
<li><a class="reference internal" href="#preprocessing-normalization">4.3.3. 归一化</a></li>
<li><a class="reference internal" href="#preprocessing-categorical-features">4.3.4. 编码 标称型特征</a></li>
<li><a class="reference internal" href="#preprocessing-discretization">4.3.5. 离散化</a><ul>
<li><a class="reference internal" href="#k-bins">4.3.5.1. K-bins 离散化</a></li>
<li><a class="reference internal" href="#preprocessing-binarization">4.3.5.2. 特征二值化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#imputation">4.3.6. 缺失值补全</a></li>
<li><a class="reference internal" href="#polynomial-features">4.3.7. 产生多项式特征</a></li>
<li><a class="reference internal" href="#function-transformer">4.3.8. 自定义变换器</a></li>
</ul>
</li>
</ul>

        <br />
        <p>
          <a href="https://study.163.com/course/introduction/1209532843.htm?share=2&shareId=400000000535031" target="_blank">
            <img src="../static/img/advitise1.png" alt="座右铭" />
          </a>
        </p>
        <br />
        <p class="doc-version" style="font-size:10%">
          注意!本网站的网址是以 <em>https://</em> 开头的，而不是以 <em>http://</em> 开头的!!!
        </p>
      </div>
    </div>
    
    <input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
    <label for="nav-trigger"></label>
    
    


    <div class="content">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="preprocessing-data">
<span id="preprocessing"></span><h1>4.3. 预处理数据(Preprocessing data)<a class="headerlink" href="#preprocessing-data" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">sklearn.preprocessing</span></code> 包提供了几个常见的实用工具函数和变换器类，用来将原始特征向量修改为更适合机器学习模型的表达形式。</p>
<p>一般来说，机器学习算法会受益于数据集的标准化。如果数据集中出现一些离群/异常值(outliers)，那么鲁棒的缩放器或变换器(scalers or transformers)更合适。
不同缩放器、变换器和归一化器(normalizer)在包含边缘离群值的数据集上的行为请参看 <a class="reference internal" href="../auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py"><span class="std std-ref">Compare the effect of different scalers on data with outliers</span></a> 。</p>
<div class="topic">
<p class="topic-title first">译者注</p>
<p>本章节视频：
<a class="reference external" href="http://www.studyai.com/course/play/d954602ecc014b1d80416b43ac848806">SKlearn数据预处理之标准化(Stardardization)</a> ;
<a class="reference external" href="http://www.studyai.com/course/play/4a8bd51565714552bcad6ec7983dce54">SKLearn数据预处理之规范化(Normalize)和二值化(Binarize)</a> ;
<a class="reference external" href="http://www.studyai.com/course/play/1be47f563bde488abde0c95baece6db2">标称型特征的编码和缺失值补全</a>。</p>
</div>
<div class="section" id="or">
<span id="preprocessing-scaler"></span><h2>4.3.1. 标准化,or 均值去除和方差缩放<a class="headerlink" href="#or" title="Permalink to this headline">¶</a></h2>
<p>数据集的 标准化(<strong>Standardization</strong>) 对 <strong>scikit-learn中实现的大多数机器学习算法来说是常见的要求</strong> 。
如果个别特征或多或少看起来不是很像标准正态分布(具有零均值和单位方差)，那么这些机器学习算法的表现可能会比较差。</p>
<p>在实践中,我们经常忽略分布的形状，直接通过去除每个特征分量的均值来对每个特征进行中心化，
再通过除以非常量特征(non-constant features)的标准差对其进行缩放。</p>
<p>例如，在机器学习算法的目标函数(例如SVM的RBF内核或线性模型的l1和l2正则化)
中有很多地方都假定了所有特征都是以0为中心而且它们的方差也具有相同的阶数。
如果某个特征的方差比其他特征大几个数量级，那么它就会在学习算法的目标函数中占据主导位置，
导致学习器并不能像我们所期望的那样，从其他特征中学习。</p>
<p>函数 <a class="reference internal" href="generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" title="sklearn.preprocessing.scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">scale</span></code></a> 提供了一个快速简单的方法来在单个 array-like 数据集上执行上述标准化操作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">preprocessing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span>                                          
<span class="go">array([[ 0.  ..., -1.22...,  1.33...],</span>
<span class="go">       [ 1.22...,  0.  ..., -0.26...],</span>
<span class="go">       [-1.22...,  1.22..., -1.06...]])</span>
</pre></div>
</div>
<p>被缩放的数据具有零均值和单位方差:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0., 0., 0.])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1., 1., 1.])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">preprocessing</span></code> 模块还提供了一个工具类 <a class="reference internal" href="generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardScaler</span></code></a> ，它实现了 <code class="docutils literal notranslate"><span class="pre">Transformer</span></code> 的API来计算训练集上的平均值和标准偏差，
以便以后能够在测试集上重新应用相同的变换。因此，这个类适用于 <a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code></a> 的早期步骤:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span>
<span class="go">StandardScaler(copy=True, with_mean=True, with_std=True)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">mean_</span>                                      <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">array([1. ..., 0. ..., 0.33...])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">scale_</span>                                       <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">array([0.81..., 0.81..., 1.24...])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>                           <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">array([[ 0.  ..., -1.22...,  1.33...],</span>
<span class="go">       [ 1.22...,  0.  ..., -0.26...],</span>
<span class="go">       [-1.22...,  1.22..., -1.06...]])</span>
</pre></div>
</div>
<p>然后，缩放器的实例就可以在新的数据上实现和训练集相同缩放操作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>                
<span class="go">array([[-2.44...,  1.22..., -0.26...]])</span>
</pre></div>
</div>
<p>你也可以通过在 <a class="reference internal" href="generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardScaler</span></code></a> 类的构造函数中传入参数 <code class="docutils literal notranslate"><span class="pre">with_mean=False</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">with_std=False</span></code> 来禁用中心化或缩放操作。</p>
<div class="section" id="id2">
<h3>4.3.1.1. 缩放特征到指定范围<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>另外一种可选的标准化(standardization)是将特征缩放到给定的最小值和最大值之间，通常在 0 和 1 之间，
或者也可以将每个特征的最大绝对值转换至单位大小。
可以分别使用 <a class="reference internal" href="generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" title="sklearn.preprocessing.MinMaxScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinMaxScaler</span></code></a> 或 <a class="reference internal" href="generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaxAbsScaler</span></code></a> 实现。</p>
<p>使用这种缩放的动机包括实现对特征的极小标准差的鲁棒性以及在稀疏矩阵中保留零元素。</p>
<p>以下是一个将简单的数据矩阵缩放到 <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code> 范围内的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_max_scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_minmax</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_minmax</span>
<span class="go">array([[0.5       , 0.        , 1.        ],</span>
<span class="go">       [1.        , 0.5       , 0.33333333],</span>
<span class="go">       [0.        , 1.        , 0.        ]])</span>
</pre></div>
</div>
<p>然后，上述变换器的同一个实例可以被用于在训练过程中不可见的新的测试数据:实现和训练数据上
一致的缩放和移位操作(scaling and shifting operations):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_minmax</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_minmax</span>
<span class="go">array([[-1.5       ,  0.        ,  1.66666667]])</span>
</pre></div>
</div>
<p>可以检查缩放器（scaler）的属性，来观察在训练集中学习到的变换操作的基本性质</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">min_max_scaler</span><span class="o">.</span><span class="n">scale_</span>                             
<span class="go">array([0.5       , 0.5       , 0.33...])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">min_max_scaler</span><span class="o">.</span><span class="n">min_</span>                               
<span class="go">array([0.        , 0.5       , 0.33...])</span>
</pre></div>
</div>
<p>如果给 <a class="reference internal" href="generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" title="sklearn.preprocessing.MinMaxScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinMaxScaler</span></code></a> 类提供一个明确的 <code class="docutils literal notranslate"><span class="pre">feature_range=(min,</span> <span class="pre">max)</span></code> ， 那么完整的公式是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">X_std</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span>
</pre></div>
</div>
<p>类 <a class="reference internal" href="generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaxAbsScaler</span></code></a> 的工作原理与 <a class="reference internal" href="generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" title="sklearn.preprocessing.MinMaxScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinMaxScaler</span></code></a> 类 非常相似，
但是它只通过除以每个特征的最大值将训练数据缩放至 <code class="docutils literal notranslate"><span class="pre">[-1,</span> <span class="pre">1]</span></code> 区间内，
这就意味着，训练数据应该是已经零中心化或者是稀疏数据。</p>
<p>用先前的例子中的数据实现最大绝对值缩放操作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_abs_scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">MaxAbsScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_maxabs</span> <span class="o">=</span> <span class="n">max_abs_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_maxabs</span>                <span class="c1"># doctest +NORMALIZE_WHITESPACE^</span>
<span class="go">array([[ 0.5, -1. ,  1. ],</span>
<span class="go">       [ 1. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  1. , -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_maxabs</span> <span class="o">=</span> <span class="n">max_abs_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_maxabs</span>                 
<span class="go">array([[-1.5, -1. ,  2. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_abs_scaler</span><span class="o">.</span><span class="n">scale_</span>         
<span class="go">array([2.,  1.,  2.])</span>
</pre></div>
</div>
<p>就像函数  <a class="reference internal" href="generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" title="sklearn.preprocessing.scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">scale</span></code></a> 一样，预处理模块进一步提供了方便的函数 <a class="reference internal" href="generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale" title="sklearn.preprocessing.minmax_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">minmax_scale</span></code></a> 和 <a class="reference internal" href="generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" title="sklearn.preprocessing.maxabs_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">maxabs_scale</span></code></a> 。
当你不想创建对象时，可以使用这些函数 。</p>
</div>
<div class="section" id="id3">
<h3>4.3.1.2. 缩放稀疏数据<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>中心化稀疏(矩阵)数据会破坏数据的稀疏结构，因此很少有一个比较合理的实现方式。但是缩放稀疏输入是有意义的，尤其是当几个特征在不同的量级范围时。</p>
<p>类 <a class="reference internal" href="generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaxAbsScaler</span></code></a>  和 函数 <a class="reference internal" href="generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" title="sklearn.preprocessing.maxabs_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">maxabs_scale</span></code></a> 是专为缩放稀疏数据而设计的，并且是缩放稀疏数据的推荐方法。
但是， 函数 <a class="reference internal" href="generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" title="sklearn.preprocessing.scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">scale</span></code></a> 和 <a class="reference internal" href="generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardScaler</span></code></a> 类也能够接受 <code class="docutils literal notranslate"><span class="pre">scipy.sparse</span></code> 作为输入，只要参数 <code class="docutils literal notranslate"><span class="pre">with_mean=False</span></code> 被显式的传入它的构造器。
否则会出现 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> 的错误，因为默默的中心化(silently centering)会破坏稀疏性，并且经常会因为分配过多的内存而使执行崩溃。
<a class="reference internal" href="generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler" title="sklearn.preprocessing.RobustScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobustScaler</span></code></a> 类不能适配(fit)稀疏输入，但你可以在稀疏输入上使用 <code class="docutils literal notranslate"><span class="pre">transform</span></code> 方法。</p>
<p>注意，缩放器(scaler)可以接受 压缩过的稀疏行 也可以接受 压缩过的稀疏列(参见 <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csc_matrix</span></code> )。
任何其他 稀疏输入将会 ** 转化为压缩稀疏行表示 ** 。为了避免不必要的内存复制，建议在早期选择 CSR 或 CSC 表示。</p>
<p>最后，如果已经中心化的数据足够小，使用 <code class="docutils literal notranslate"><span class="pre">toarray</span></code> 方法将输入的稀疏矩阵显式转换为数组是另一种选择。</p>
</div>
<div class="section" id="id4">
<h3>4.3.1.3. 缩放带有异常值的数据<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>如果你的数据包含许多异常值，使用均值和方差缩放可能并不是一个很好的选择。
这种情况下，你可以使用 <a class="reference internal" href="generated/sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" title="sklearn.preprocessing.robust_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">robust_scale</span></code></a> 以及 <a class="reference internal" href="generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler" title="sklearn.preprocessing.RobustScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobustScaler</span></code></a> 作为替代品。
它们对你的数据的中心和范围使用更有鲁棒性的估计。</p>
<div class="topic">
<p class="topic-title first">参考文献:</p>
<p>更多关于中心化和缩放数据的重要性讨论在此FAQ中提及: <a class="reference external" href="http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html">Should I normalize/standardize/rescale the data?</a></p>
</div>
<div class="topic">
<p class="topic-title first">缩放与白化(Scaling vs Whitening)</p>
<p>有时候独立地中心化和缩放数据是不够的，因为下游的机器学习模型会进一步对特征之间的线性依赖做出一些假设。</p>
<p>要解决这个问题，你可以使用 <a class="reference internal" href="generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.PCA</span></code></a> 类 并指定参数 <code class="docutils literal notranslate"><span class="pre">whiten=True</span></code> 来进一步移除特征间的线性关联。</p>
</div>
<div class="topic">
<p class="topic-title first">缩放一个 1D array</p>
<p>上面介绍过的所有函数(i.e. <a class="reference internal" href="generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" title="sklearn.preprocessing.scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">scale</span></code></a>, <a class="reference internal" href="generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale" title="sklearn.preprocessing.minmax_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">minmax_scale</span></code></a>, <a class="reference internal" href="generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" title="sklearn.preprocessing.maxabs_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">maxabs_scale</span></code></a>, 和 <a class="reference internal" href="generated/sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" title="sklearn.preprocessing.robust_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">robust_scale</span></code></a>)
都可以直接处理一维数组。</p>
</div>
</div>
<div class="section" id="kernel-centering">
<span id="id5"></span><h3>4.3.1.4. 中心化 核矩阵<a class="headerlink" href="#kernel-centering" title="Permalink to this headline">¶</a></h3>
<p>如果你有一个 核 <span class="math notranslate nohighlight">\(K\)</span> 的核矩阵(其中，核 <span class="math notranslate nohighlight">\(K\)</span> 在 由函数 <span class="math notranslate nohighlight">\(phi\)</span> 定义的特征空间上计算点积(dot product)),
类 <a class="reference internal" href="generated/sklearn.preprocessing.KernelCenterer.html#sklearn.preprocessing.KernelCenterer" title="sklearn.preprocessing.KernelCenterer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KernelCenterer</span></code></a> 可以 变换 核矩阵(kernel matrix) 以使得它包含由函数 <span class="math notranslate nohighlight">\(phi\)</span>
定义的被去除了均值的特征空间上的内积(inner products)。</p>
</div>
</div>
<div class="section" id="preprocessing-transformer">
<span id="id6"></span><h2>4.3.2. 非线性变换<a class="headerlink" href="#preprocessing-transformer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id7">
<h3>4.3.2.1. 映射到均匀分布<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>类似于缩放器(scalers)， <a class="reference internal" href="generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" title="sklearn.preprocessing.QuantileTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantileTransformer</span></code></a> 类将 所有特征 放到 同样的已知范围 或 同样的已知分布 下。
但是，通过执行一个排序变换(rank transformation), 它能够使 异常的分布(unusual distributions) 被平滑化，
并且能够做到 比使用缩放器(scalers)方法 更少地受到离群值的影响。
然而，它的确使 特征间 及 特征内 的 关联和距离 被打乱了。</p>
<p>类 <a class="reference internal" href="generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" title="sklearn.preprocessing.QuantileTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantileTransformer</span></code></a> 和 函数 <a class="reference internal" href="generated/sklearn.preprocessing.quantile_transform.html#sklearn.preprocessing.quantile_transform" title="sklearn.preprocessing.quantile_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">quantile_transform</span></code></a>
提供了一个 基于分位数函数的无参数变换器 将数据映射到一个取值在0到1之间的均匀分布上</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="k">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quantile_transformer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_trans</span> <span class="o">=</span> <span class="n">quantile_transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_trans</span> <span class="o">=</span> <span class="n">quantile_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X_train</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span> 
<span class="go">array([ 4.3,  5.1,  5.8,  6.5,  7.9])</span>
</pre></div>
</div>
<p>这个特征对应于萼片的长度(以厘米为单位)。一旦应用分位数变换，这些landmarks就接近于之前定义的百分位数</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X_train_trans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="gp">... </span>
<span class="go">array([ 0.00... ,  0.24...,  0.49...,  0.73...,  0.99... ])</span>
</pre></div>
</div>
<p>这可以在带有类似remarks的独立测试集上得到确认</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X_test</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="gp">... </span>
<span class="go">array([ 4.4  ,  5.125,  5.75 ,  6.175,  7.3  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X_test_trans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="gp">... </span>
<span class="go">array([ 0.01...,  0.25...,  0.46...,  0.60... ,  0.94...])</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>4.3.2.2. 映射到高斯分布<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>在许多建模场景中，需要数据集中的特征的正态化(normality)。幂变换(Power transforms)是一类参数化的单调变换(parametric, monotonic transformations)，
其目的是将数据从任何分布映射到尽可能接近高斯分布，以便稳定方差(stabilize variance)和最小化偏斜(minimize skewness)。</p>
<p>类 <a class="reference internal" href="generated/sklearn.preprocessing.PowerTransformer.html#sklearn.preprocessing.PowerTransformer" title="sklearn.preprocessing.PowerTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerTransformer</span></code></a> 目前提供两个这样的幂变换,the Yeo-Johnson transform 和 the Box-Cox transform。</p>
<p>The Yeo-Johnson transform 如下定义:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x_i^{(\lambda)} =
\begin{cases}
 [(x_i + 1)^\lambda - 1] / \lambda &amp; \text{if } \lambda \neq 0, x_i \geq 0, \\[8pt]
\ln{(x_i) + 1} &amp; \text{if } \lambda = 0, x_i \geq 0 \\[8pt]
-[(-x_i + 1)^{2 - \lambda} - 1] / (2 - \lambda) &amp; \text{if } \lambda \neq 2, x_i &lt; 0, \\[8pt]
 - \ln (- x_i + 1) &amp; \text{if } \lambda = 2, x_i &lt; 0
\end{cases}\end{split}\]</div>
<p>而 the Box-Cox transform 如下定义:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x_i^{(\lambda)} =
\begin{cases}
\dfrac{x_i^\lambda - 1}{\lambda} &amp; \text{if } \lambda \neq 0, \\[8pt]
\ln{(x_i)} &amp; \text{if } \lambda = 0,
\end{cases}\end{split}\]</div>
<p>Box-Cox 仅能被应用于严格正(positive)的数据上。 在这两种方法中，变换(transformation)通过 <span class="math notranslate nohighlight">\(\lambda\)</span> 被参数化：
参数 <span class="math notranslate nohighlight">\(\lambda\)</span> 的值可以通过极大似然估计法(maximum likelihood estimation)得到。这里有一个使用例子：使用 Box-Cox
把从对数正态分布(lognormal distribution)抽取出的样本映射成服从正太分布(normal distribution)的数据:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">PowerTransformer</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;box-cox&#39;</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_lognormal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">616</span><span class="p">)</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_lognormal</span>                                         
<span class="go">array([[1.28..., 1.18..., 0.84...],</span>
<span class="go">       [0.94..., 1.60..., 0.38...],</span>
<span class="go">       [1.35..., 0.21..., 1.09...]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_lognormal</span><span class="p">)</span>                   
<span class="go">array([[ 0.49...,  0.17..., -0.15...],</span>
<span class="go">       [-0.05...,  0.58..., -0.57...],</span>
<span class="go">       [ 0.69..., -0.84...,  0.10...]])</span>
</pre></div>
</div>
<p>上述例子设置了参数 <cite>standardize</cite> 的选项为 <cite>False</cite> 。  但是，默认情况下，类 <a class="reference internal" href="generated/sklearn.preprocessing.PowerTransformer.html#sklearn.preprocessing.PowerTransformer" title="sklearn.preprocessing.PowerTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerTransformer</span></code></a> 将会应用
zero-mean, unit-variance normalization 到变换出的输出上。</p>
<p>下面的例子中 将 Box-Cox 和 Yeo-Johnson 应用到各种不同的概率分布上。 请注意 当把这些方法用到某个分布上的时候，
幂变换得到的分布非常像高斯分布。但是对其他的一些分布，结果却不太有效。这更加强调了在幂变换前后对数据进行可视化的重要性。</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/preprocessing/plot_map_data_to_normal.html"><img alt="../images/sphx_glr_plot_map_data_to_normal_0011.png" src="../images/sphx_glr_plot_map_data_to_normal_0011.png" style="width: 400.0px; height: 800.0px;" /></a>
</div>
<p>我们也可以 使用类 <a class="reference internal" href="generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" title="sklearn.preprocessing.QuantileTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantileTransformer</span></code></a> (通过设置 <code class="docutils literal notranslate"><span class="pre">output_distribution='normal'</span></code>)把数据
变换成一个正态分布。下面是将其应用到iris dataset上的结果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">quantile_transformer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">QuantileTransformer</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">output_distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_trans</span> <span class="o">=</span> <span class="n">quantile_transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quantile_transformer</span><span class="o">.</span><span class="n">quantiles_</span> 
<span class="go">array([[4.3...,   2...,     1...,     0.1...],</span>
<span class="go">       [4.31...,  2.02...,  1.01...,  0.1...],</span>
<span class="go">       [4.32...,  2.05...,  1.02...,  0.1...],</span>
<span class="go">       ...,</span>
<span class="go">       [7.84...,  4.34...,  6.84...,  2.5...],</span>
<span class="go">       [7.87...,  4.37...,  6.87...,  2.5...],</span>
<span class="go">       [7.9...,   4.4...,   6.9...,   2.5...]])</span>
</pre></div>
</div>
<p>因此，输入的中值(median)变成了输出的均值(mean)，以 0 为中心。正态输出被裁剪以便输入的最大最小值(分别对应于 1e-7 和 1 - 1e-7)不会在变换之下变成无穷。</p>
</div>
</div>
<div class="section" id="preprocessing-normalization">
<span id="id9"></span><h2>4.3.3. 归一化<a class="headerlink" href="#preprocessing-normalization" title="Permalink to this headline">¶</a></h2>
<p>归一化(<strong>Normalization</strong>) 是 <strong>缩放单个样本使其具有单位范数</strong> 的过程。
如果你计划使用二次形式(quadratic form 如点积或任何其他核函数)来量化任何样本间的相似度，则此过程将非常有用。</p>
<p>这个 assumption 是 向量空间模型(<a class="reference external" href="https://en.wikipedia.org/wiki/Vector_Space_Model">Vector Space Model</a> ) 的基础，经常在文本分类和内容聚类中使用.</p>
<p>函数 <a class="reference internal" href="generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" title="sklearn.preprocessing.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">normalize</span></code></a> 提供了一个快速简单的方法在类似数组的数据集上执行操作，使用 <code class="docutils literal notranslate"><span class="pre">l1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">l2</span></code> 范数</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span>                                      
<span class="go">array([[ 0.40..., -0.40...,  0.81...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 0.  ...,  0.70..., -0.70...]])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">preprocessing</span></code> 模块提供的工具类  <a class="reference internal" href="generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalizer</span></code></a> 使用 <code class="docutils literal notranslate"><span class="pre">Transformer</span></code> API 实现了相同的操作
(尽管在这种情况下， <code class="docutils literal notranslate"><span class="pre">fit</span></code> 方法是没有用的：该类是无状态的，因为归一化操作独立的对待样本)。</p>
<p>因此这个类适用于 <a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code></a> 的早期步骤</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Normalizer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># fit does nothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span>
<span class="go">Normalizer(copy=True, norm=&#39;l2&#39;)</span>
</pre></div>
</div>
<p>在这之后 归一化器的实例 就可以被使用在样本向量中，像任何其他变换器一样</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                            
<span class="go">array([[ 0.40..., -0.40...,  0.81...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 0.  ...,  0.70..., -0.70...]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>             
<span class="go">array([[-0.70...,  0.70...,  0.  ...]])</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">稀疏输入</p>
<p>函数 <a class="reference internal" href="generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" title="sklearn.preprocessing.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">normalize</span></code></a> 和 类 <a class="reference internal" href="generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalizer</span></code></a> 接受 <strong>both dense array-like
and sparse matrices from scipy.sparse 作为输入</strong>.</p>
<p>对于稀疏输入，在被提交给高效Cython例程前，数据被 <strong>转化为压缩的稀疏行形式</strong> (参见 <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code> )。
为了避免不必要的内存复制，推荐在上游选择CSR表示。</p>
</div>
</div>
<div class="section" id="preprocessing-categorical-features">
<span id="id10"></span><h2>4.3.4. 编码 标称型特征<a class="headerlink" href="#preprocessing-categorical-features" title="Permalink to this headline">¶</a></h2>
<p>在机器学习中，特征经常不是连续的数值型的而是 标称型的(categorical)。举个例子，一个人的特征可能有
<code class="docutils literal notranslate"><span class="pre">[&quot;male&quot;,</span> <span class="pre">&quot;female&quot;]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[&quot;from</span> <span class="pre">Europe&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">US&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">Asia&quot;]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[&quot;uses</span> <span class="pre">Firefox&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Chrome&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Safari&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Internet</span> <span class="pre">Explorer&quot;]</span></code> 等。
这些特征能够被有效地编码成整数，比如 <code class="docutils literal notranslate"><span class="pre">[&quot;male&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">US&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Internet</span> <span class="pre">Explorer&quot;]</span></code> 可以被表示为 [0, 1, 3] ，
<code class="docutils literal notranslate"><span class="pre">[&quot;female&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">Asia&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Chrome&quot;]</span></code> 表示为 [1, 2, 1] 。</p>
<p>要把 标称型特征(categorical features) 转换为 这样的整数编码(integer codes), 我们可以使用 <a class="reference internal" href="generated/sklearn.preprocessing.OrdinalEncoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrdinalEncoder</span></code></a> 。
这个 etimator 把每一个 categorical feature 变换成 一个新的整数数字特征 (0 到 n_categories - 1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">OrdinalEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Firefox&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  
<span class="go">OrdinalEncoder(categories=&#39;auto&#39;, dtype=&lt;... &#39;numpy.float64&#39;&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">]])</span>
<span class="go">array([[0., 1., 1.]])</span>
</pre></div>
</div>
<p>这样的整数特征表示并不能在scikit-learn的估计器中直接使用，因为这样的连续输入，
估计器会认为类别之间是有序的，但实际却是无序的。(例如：浏览器的类别数据则是任意排序的)。</p>
<p>另外一种将 categorical features 转换为能够被scikit-learn中模型使用的编码是 one-of-K， 又称之为 one-hot 编码 或 dummy encoding。
这种编码类型已经在类 <a class="reference internal" href="generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneHotEncoder</span></code></a> 中实现。该类把每一个具有 <code class="docutils literal notranslate"><span class="pre">n_categories</span></code> 个可能取值的 categorical特征 变换为
长度为 <code class="docutils literal notranslate"><span class="pre">n_categories</span></code> 的二进制特征向量，里面只有一个地方是1，其余位置都是0。</p>
<p>继续我们上面的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">OneHotEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Firefox&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  
<span class="go">OneHotEncoder(categorical_features=None, categories=None,</span>
<span class="go">       dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;,</span>
<span class="go">       n_values=None, sparse=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;from Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 0., 0., 1., 0., 1.],</span>
<span class="go">       [0., 1., 1., 0., 0., 1.]])</span>
</pre></div>
</div>
<p>默认情况下，每个特征使用几维的数值可以从数据集自动推断。而且可以在属性 <code class="docutils literal notranslate"><span class="pre">categories_</span></code> 中找到:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;female&#39;, &#39;male&#39;], dtype=object), array([&#39;from Europe&#39;, &#39;from US&#39;], dtype=object), array([&#39;uses Firefox&#39;, &#39;uses Safari&#39;], dtype=object)]</span>
</pre></div>
</div>
<p>当然，你也可以通过使用参数 <code class="docutils literal notranslate"><span class="pre">categories</span></code> 来明确指定。在我们的例子数据集中，有两个性别类，四个可能的洲，四个网络浏览器</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">genders</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;male&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;from Africa&#39;</span><span class="p">,</span> <span class="s1">&#39;from Asia&#39;</span><span class="p">,</span> <span class="s1">&#39;from Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">browsers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;uses Chrome&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Firefox&#39;</span><span class="p">,</span> <span class="s1">&#39;uses IE&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="n">genders</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">browsers</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note that for there are missing categorical values for the 2nd and 3rd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Firefox&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> 
<span class="go">OneHotEncoder(categorical_features=None,</span>
<span class="go">       categories=[...],</span>
<span class="go">       dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;error&#39;,</span>
<span class="go">       n_values=None, sparse=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from Asia&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Chrome&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]])</span>
</pre></div>
</div>
<p>如果训练数据中可能含有缺失的categrical features, 通过指定 <code class="docutils literal notranslate"><span class="pre">handle_unknown='ignore'</span></code> 通常比像上面代码那样手动设置 <code class="docutils literal notranslate"><span class="pre">categories</span></code> 更好。
当 <code class="docutils literal notranslate"><span class="pre">handle_unknown='ignore'</span></code> 被指定后，并且在变换过程中真的碰到了未知的 categories, 则 不会抛出任何错误但是由此产生的该特征的 one-hot 编码列
将会全部变成 0 。(这个参数设置选项 <code class="docutils literal notranslate"><span class="pre">handle_unknown='ignore'</span></code> 仅仅在 one-hot encoding 的时候得到支持):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">handle_unknown</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;male&#39;</span><span class="p">,</span> <span class="s1">&#39;from US&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Safari&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Firefox&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> 
<span class="go">OneHotEncoder(categorical_features=None, categories=None,</span>
<span class="go">       dtype=&lt;... &#39;numpy.float64&#39;&gt;, handle_unknown=&#39;ignore&#39;,</span>
<span class="go">       n_values=None, sparse=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;female&#39;</span><span class="p">,</span> <span class="s1">&#39;from Asia&#39;</span><span class="p">,</span> <span class="s1">&#39;uses Chrome&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 0., 0., 0., 0., 0.]])</span>
</pre></div>
</div>
<p>请查看 <a class="reference internal" href="feature_extraction.html#dict-feature-extraction"><span class="std std-ref">从字典加载特征</span></a> 用于表示成字典形式的标称型特征而不是标量形式。</p>
</div>
<div class="section" id="preprocessing-discretization">
<span id="id11"></span><h2>4.3.5. 离散化<a class="headerlink" href="#preprocessing-discretization" title="Permalink to this headline">¶</a></h2>
<p>离散化 (<a class="reference external" href="https://en.wikipedia.org/wiki/Discretization_of_continuous_features">Discretization</a>)
(有些时候叫 量化(quantization) 或 装箱(binning)) 提供了将连续特征划分为离散特征值的方法。
某些具有连续特征的数据集会受益于离散化，因为 离散化可以把具有连续属性的数据集变换成只有名义属性(nominal attributes)的数据集。
(译者注： nominal attributes 其实就是 categorical features, 可以译为 名称属性，名义属性，符号属性，离散属性 等)</p>
<p>One-hot 编码的离散化特征 可以使得一个模型更加的有表现力(expressive)，同时还能保留其可解释性(interpretability)。
比如，用离散化器进行预处理可以给线性模型引入非线性。</p>
<div class="section" id="k-bins">
<h3>4.3.5.1. K-bins 离散化<a class="headerlink" href="#k-bins" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.preprocessing.KBinsDiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KBinsDiscretizer</span></code></a> 类使用 <code class="docutils literal notranslate"><span class="pre">k</span></code> 个等宽的 bins 把特征离散化</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mi">15</span> <span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mi">14</span> <span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mi">11</span> <span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">KBinsDiscretizer</span><span class="p">(</span><span class="n">n_bins</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">encode</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>默认情况下，输出是被 one-hot 编码到一个稀疏矩阵。(请看 <a class="reference internal" href="#preprocessing-categorical-features"><span class="std std-ref">编码 标称型特征</span></a>)。
而且可以使用参数 <code class="docutils literal notranslate"><span class="pre">encode</span></code> 进行配置。对每一个特征， bin 的边界以及总数目 在 <code class="docutils literal notranslate"><span class="pre">fit</span></code> 过程中被计算出来，它们将用来定义区间。
因此，对现在的例子，这些区间间隔被定义如下:</p>
<blockquote>
<div><ul class="simple">
<li>feature 1: <span class="math notranslate nohighlight">\({[-\infty, -1), [-1, 2), [2, \infty)}\)</span></li>
<li>feature 2: <span class="math notranslate nohighlight">\({[-\infty, 5), [5, \infty)}\)</span></li>
<li>feature 3: <span class="math notranslate nohighlight">\({[-\infty, 14), [14, \infty)}\)</span></li>
</ul>
</div></blockquote>
<p>基于这些 bin 区间, <code class="docutils literal notranslate"><span class="pre">X</span></code> 就被变换成下面这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                      
<span class="go">array([[ 0., 1., 1.],</span>
<span class="go">       [ 1., 1., 1.],</span>
<span class="go">       [ 2., 0., 0.]])</span>
</pre></div>
</div>
<p>由此产生的数据集包含了有序属性(ordinal attributes),可以被进一步用在类  <a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code></a> 中。</p>
<p>离散化(Discretization) 类似于为连续数据构建直方图(histograms)。
然而，直方图聚焦于统计特征落在特定的bins里面的数量，而离散化聚焦于给这些bins分配特征取值。</p>
<p><a class="reference internal" href="generated/sklearn.preprocessing.KBinsDiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KBinsDiscretizer</span></code></a> 类实现了不同的 binning 策略，可以通过参数 <code class="docutils literal notranslate"><span class="pre">strategy</span></code> 进行选择。 ‘uniform’ 策略使用固定宽度的bins。
‘quantile’ 策略在每个特征上使用 分位数(quantiles)值以便具有相同填充的bins。
‘kmeans’ 策略基于 在每个特征上独立执行的 k-means 聚类过程 定义bins。</p>
<div class="topic">
<p class="topic-title first">案例:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/preprocessing/plot_discretization.html#sphx-glr-auto-examples-preprocessing-plot-discretization-py"><span class="std std-ref">Using KBinsDiscretizer to discretize continuous features</span></a></li>
<li><a class="reference internal" href="../auto_examples/preprocessing/plot_discretization_classification.html#sphx-glr-auto-examples-preprocessing-plot-discretization-classification-py"><span class="std std-ref">Feature discretization</span></a></li>
<li><a class="reference internal" href="../auto_examples/preprocessing/plot_discretization_strategies.html#sphx-glr-auto-examples-preprocessing-plot-discretization-strategies-py"><span class="std std-ref">Demonstrating the different strategies of KBinsDiscretizer</span></a></li>
</ul>
</div>
</div>
<div class="section" id="preprocessing-binarization">
<span id="id12"></span><h3>4.3.5.2. 特征二值化<a class="headerlink" href="#preprocessing-binarization" title="Permalink to this headline">¶</a></h3>
<p>特征二值化(<strong>Feature binarization</strong>) 是 <strong>将数值特征用阈值过滤得到布尔值</strong> 的过程。这对于pipeline中下游的概率型模型是有用的，
它们假设输入数据是 多值伯努利分布(multi-variate <a class="reference external" href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli distribution</a>) 。
例如这个模型 <a class="reference internal" href="generated/sklearn.neural_network.BernoulliRBM.html#sklearn.neural_network.BernoulliRBM" title="sklearn.neural_network.BernoulliRBM"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.neural_network.BernoulliRBM</span></code></a> 就用到了 多值伯努利分布 。</p>
<p>即使 归一化计数(a.k.a. term frequencies) 和 TF-IDF值特征 在实践中表现稍好一些，
在文本处理社区中也常常使用二值化特征值(这可能会简化概率推理(probabilistic reasoning))。</p>
<p>与 <a class="reference internal" href="generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalizer</span></code></a> 类一样，工具类 <a class="reference internal" href="generated/sklearn.preprocessing.Binarizer.html#sklearn.preprocessing.Binarizer" title="sklearn.preprocessing.Binarizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binarizer</span></code></a> 也被用于 <a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code></a> 的早期步骤中。
因为每个样本被当做是独立于其他样本的，所以 <code class="docutils literal notranslate"><span class="pre">fit</span></code> 方法是不做任何事的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Binarizer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># fit does nothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span>
<span class="go">Binarizer(copy=True, threshold=0.0)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[1., 0., 1.],</span>
<span class="go">       [1., 0., 0.],</span>
<span class="go">       [0., 1., 0.]])</span>
</pre></div>
</div>
<p>二值化器(binarizer)的阈值是可以被调节的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Binarizer</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [1., 0., 0.],</span>
<span class="go">       [0., 0., 0.]])</span>
</pre></div>
</div>
<p>与 <a class="reference internal" href="generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardScaler</span></code></a> 类 和 <a class="reference internal" href="generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalizer</span></code></a> 类一样， 预处理模块也提供了一个函数 <a class="reference internal" href="generated/sklearn.preprocessing.binarize.html#sklearn.preprocessing.binarize" title="sklearn.preprocessing.binarize"><code class="xref py py-func docutils literal notranslate"><span class="pre">binarize</span></code></a>
供我们使用，当 变换器(transformer) API 并不是必须的 的时候。</p>
<p>请注意 当 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">2</span></code> ， 和 当 bin edge is at the value <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 时， <a class="reference internal" href="generated/sklearn.preprocessing.Binarizer.html#sklearn.preprocessing.Binarizer" title="sklearn.preprocessing.Binarizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binarizer</span></code></a> 与 <a class="reference internal" href="generated/sklearn.preprocessing.KBinsDiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KBinsDiscretizer</span></code></a> 是类似的。</p>
<div class="topic">
<p class="topic-title first">稀疏输入</p>
<p>函数 <a class="reference internal" href="generated/sklearn.preprocessing.binarize.html#sklearn.preprocessing.binarize" title="sklearn.preprocessing.binarize"><code class="xref py py-func docutils literal notranslate"><span class="pre">binarize</span></code></a> 和 类 <a class="reference internal" href="generated/sklearn.preprocessing.Binarizer.html#sklearn.preprocessing.Binarizer" title="sklearn.preprocessing.Binarizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binarizer</span></code></a> 都接受 <strong>稠密数组型的输入</strong>，和 <strong>来自 scipy.sparse 的稀疏矩阵作为输入</strong> 。</p>
<p>对于 稀疏输入，数据被转换为 <strong>Compressed Sparse Rows representation</strong> (请看 <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code>).
为了避免不必要的内存拷贝, 在pipeline的早期阶段 推荐使用 CSR representation。</p>
</div>
</div>
</div>
<div class="section" id="imputation">
<span id="id13"></span><h2>4.3.6. 缺失值补全<a class="headerlink" href="#imputation" title="Permalink to this headline">¶</a></h2>
<p>关于 缺失值(missing values) 补全的方法和工具 的讨论，请看章节: <a class="reference internal" href="impute.html#impute"><span class="std std-ref">缺失值处理(Imputation of missing values)</span></a> 。</p>
</div>
<div class="section" id="polynomial-features">
<span id="id14"></span><h2>4.3.7. 产生多项式特征<a class="headerlink" href="#polynomial-features" title="Permalink to this headline">¶</a></h2>
<p>通常，在机器学习中，通过使用一些输入数据的非线性特征来增加模型的复杂度是有用的。
一个简单通用的办法是使用多项式特征(polynomial features)，这可以获得特征的更高阶次和互相间关系的 项(terms)。
上述功能已经在 <a class="reference internal" href="generated/sklearn.preprocessing.PolynomialFeatures.html#sklearn.preprocessing.PolynomialFeatures" title="sklearn.preprocessing.PolynomialFeatures"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialFeatures</span></code></a> 类中实现</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">PolynomialFeatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>                                                 
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                             
<span class="go">array([[ 1.,  0.,  1.,  0.,  0.,  1.],</span>
<span class="go">       [ 1.,  2.,  3.,  4.,  6.,  9.],</span>
<span class="go">       [ 1.,  4.,  5., 16., 20., 25.]])</span>
</pre></div>
</div>
<p>X 的特征向量 已经从 <span class="math notranslate nohighlight">\((X_1, X_2)\)</span> 变换为 <span class="math notranslate nohighlight">\((1, X_1, X_2, X_1^2, X_1X_2, X_2^2)\)</span> 。</p>
<p>在有些情形下, 仅仅需要特征之间的相互作用项(interaction terms among features), 这时候通过设置 <code class="docutils literal notranslate"><span class="pre">interaction_only=True</span></code> 就可以得到我们
想要的 相互作用项</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>                                                 
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">interaction_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                             
<span class="go">array([[  1.,   0.,   1.,   2.,   0.,   0.,   2.,   0.],</span>
<span class="go">       [  1.,   3.,   4.,   5.,  12.,  15.,  20.,  60.],</span>
<span class="go">       [  1.,   6.,   7.,   8.,  42.,  48.,  56., 336.]])</span>
</pre></div>
</div>
<p>X 的特征向量 已经从 <span class="math notranslate nohighlight">\((X_1, X_2, X_3)\)</span> 变换为 <span class="math notranslate nohighlight">\((1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)\)</span>.</p>
<p>请注意，当我们使用多项式核 <a class="reference internal" href="svm.html#svm-kernels"><span class="std std-ref">核函数</span></a> 的时候， 多项式特征 在 <a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_method">kernel methods</a> 中被隐式的使用了。
(比如说, <a class="reference internal" href="generated/sklearn.svm.SVC.html#sklearn.svm.SVC" title="sklearn.svm.SVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.svm.SVC</span></code></a>, <a class="reference internal" href="generated/sklearn.decomposition.KernelPCA.html#sklearn.decomposition.KernelPCA" title="sklearn.decomposition.KernelPCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.KernelPCA</span></code></a>)。</p>
<p>See <a class="reference internal" href="../auto_examples/linear_model/plot_polynomial_interpolation.html#sphx-glr-auto-examples-linear-model-plot-polynomial-interpolation-py"><span class="std std-ref">Polynomial interpolation</span></a> for Ridge regression using created polynomial features.</p>
</div>
<div class="section" id="function-transformer">
<span id="id15"></span><h2>4.3.8. 自定义变换器<a class="headerlink" href="#function-transformer" title="Permalink to this headline">¶</a></h2>
<p>通常，在机器学习中，你可能想要将一个已有的 Python 函数转化为一个变换器(transformer)来协助数据清理或处理。
你可以使用 <a class="reference internal" href="generated/sklearn.preprocessing.FunctionTransformer.html#sklearn.preprocessing.FunctionTransformer" title="sklearn.preprocessing.FunctionTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTransformer</span></code></a> 类从任意函数中实现一个transformer。例如，在一个pipeline中构建一个实现日志转换的transformer，
就可以这样做</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">FunctionTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[0.        , 0.69314718],</span>
<span class="go">       [1.09861229, 1.38629436]])</span>
</pre></div>
</div>
<p>你可以保证 <code class="docutils literal notranslate"><span class="pre">func</span></code> 和 <code class="docutils literal notranslate"><span class="pre">inverse_func</span></code> 是互为可逆的(the inverse of each other) 通过设置 <code class="docutils literal notranslate"><span class="pre">check_inverse=True</span></code> 并且在 调用 <code class="docutils literal notranslate"><span class="pre">transform</span></code> 之前
调用 <code class="docutils literal notranslate"><span class="pre">fit</span></code> 。 请注意 一个 warning 会被抛出，并且 可以使用 <code class="docutils literal notranslate"><span class="pre">filterwarnings</span></code> 将其转为一个 error</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;.*check_inverse*.&quot;</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>我们提供了一个完整的代码案例来展示 <a class="reference internal" href="generated/sklearn.preprocessing.FunctionTransformer.html#sklearn.preprocessing.FunctionTransformer" title="sklearn.preprocessing.FunctionTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTransformer</span></code></a> 类进行自定义特征选择的用法，请看：
<a class="reference internal" href="../auto_examples/preprocessing/plot_function_transformer.html#sphx-glr-auto-examples-preprocessing-plot-function-transformer-py"><span class="std std-ref">Using FunctionTransformer to select columns</span></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </div>
  
  <div class="footer">
    &copy; 2007 - 2018, scikit-learn developers (BSD License).
    <!--
    <a href="../_sources/modules/preprocessing.rst.txt" rel="nofollow">Show this page source</a> -->
  </div>
  <div class="rel">
    
      <div class="buttonPrevious">
        <a href="feature_extraction.html">Previous
        </a>
      </div>
      <div class="buttonNext">
        <a href="impute.html">Next
        </a>
      </div>
      
    </div>

    
    <script>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) }; ga.l = +new Date;
      ga('create', 'UA-22606712-2', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
    
    <script>
      (function () {
        var cx = '016639176250731907682:tjtqbvtvij0';
        var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
      })();
    </script>
  </body>
</html>